---
title: "dsb advanced topics: step by step model intuition"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dsb advanced topics: step by step model intuition}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


The purpose of this document is for advanced users or users interested in the underlying model / how the code under the hood of the dsb method is implemented in a step by step manner as outlined in the methods section of the paper. 

**All of the steps outlined below are carried out in a single step with the `DSBNormalizeProtein()` function.** 

```{r}
suppressMessages(library(mclust))
suppressMessages(library(ggplot2))
library(dsb) 
```

## Load example package data 
h1 is a random subset of ~2000 cells from our PBMC data and neg are background drops. 
```{r}
h1 = dsb::cells_citeseq_mtx
neg = dsb::empty_drop_citeseq_mtx
```

## log transform 
Log transform background droplets 
```{r}
# log transformation
dlog = log(h1 + 10)
nlog = log(neg + 10)
```

## calculate summary stats for cells and background. 
Calculate the mean and standard deviation of the log transformed cells and background droplets. 

```{r}
# calc mean and sd of background drops 
sd_nlog = apply(nlog, 1 , sd)
mean_nlog = apply(nlog, 1 , mean)

```


Here we examine the mean variance of cells and background in the log transformed space. There is clear over-dispersion in the cell containing droplets relative to the background / empty drops. 

```{r, fig.width=6}

# compare mean and sd of cells to mean and sd of background
p1 = qplot(mean_nlog, sd_nlog) + xlim(c(2,6)) + ylim(c(0,1.5)) + ggtitle('background')
p2 = qplot(apply(dlog, 1 , mean), apply(dlog, 1 , sd)) + xlim(c(2,6)) + ylim(c(0,1.5)) + ggtitle('cells')
cowplot::plot_grid(p1,p2)

```

dsb step 1 background rescaling 

In step I, protein counts in empty droplets are used to estimate the expected ambient background noise for each antibody. Each protein’s counts in cell-containing droplets are thus rescaled using this expected noise measurement. 

```{r}
# rescale cells based on expected noise (mean and sd as calculated above) in background 
norm_adt = apply(dlog, 2, function(x) (x  - mean_nlog) / sd_nlog) 

```

Below we check distribution of ambient corrected data. If using the option `denoise.counts = FALSE` then this ambient corrected data is returned. In our experiments, we found that this captures the ambient component of protein specific noise. 

```{r, fig.width=8}
# check structure of denoised data with zero centering of background population 
p1 = qplot(as.data.frame(t(norm_adt))$CD4_PROT, 
      as.data.frame(t(norm_adt))$CD14_PROT, size = I(0.2)) + 
  ggtitle('dsb step 1 only') + 
  xlim(c(-5, 15)) + ylim(c(-5,15)) + 
  geom_density_2d(color = 'red') + 
  geom_vline(xintercept = 0) + geom_hline(yintercept = 0)

# raw data 
p2 = qplot(as.data.frame(t(h1))$CD4_PROT, 
      as.data.frame(t(h1))$CD14_PROT, size = I(0.2)) + 
  ggtitle('RAW data') + 
  geom_density_2d(color = 'red') + 
  geom_vline(xintercept = 0) + geom_hline(yintercept = 0)

# log transformed data 
p3= qplot(as.data.frame(t(dlog))$CD4_PROT, 
      as.data.frame(t(dlog))$CD14_PROT, size = I(0.2)) + 
  ggtitle('log transformed') + 
  geom_density_2d(color = 'red') + 
  geom_vline(xintercept = 0) + geom_hline(yintercept = 0)

# examine distributions. 
cowplot::plot_grid(p1,p2,p3, nrow = 1)
```

## dsb step II Part I 

Fit gaussian mixture model to each cell and extract mu 1, each cells background mean. As we outline in the paper, cells do not need to have a bimodal distribution for the background mean to be robustly extracted from a 2-component Gaussian mixture. This was tested on datasets ranging from 17 to 87 proteins. 


```{r, fig.width=4.5}
# fit 2 component Gaussian mixture to each cell 
cellwise_model1 = apply(norm_adt, 2, function(x) {
  g = Mclust(x, G=2,  warn = TRUE , verbose = FALSE)  
  return(g) 
})

# extract mu 1 as a vector 
cellwise_background_mean = lapply(cellwise_model1, 
                                  function(x){x$parameters$mean[1]
                                    }) %>% unlist()

# check distribution of the fitted value for µ1 across cells 
hist(cellwise_background_mean) 

```

## dsb Part II step II

Create noise matrix for calculaing the technical component. 

```{r}
# define isotype controls 
isotype.control.name.vec = c("Mouse IgG2bkIsotype_PROT", "MouseIgG1kappaisotype_PROT", 
                             "MouseIgG2akappaisotype_PROT", "RatIgG2bkIsotype_PROT" )
# construct noise matrix 
noise_matrix = rbind(norm_adt[isotype.control.name.vec, ], cellwise_background_mean)

# transpose to fit PC 
tmat = t(noise_matrix)

# view the noise matrix on which to calculate pc1 scores. 
tmat %>% head 
```

Next we calculate PC1 score for cells based on their noise variables. rotation = the loadings, x = the position for each observation along each principal component (the PC scores). These PC scores are the dsb technical component. 

```{r, fig.width=4.5}
# calculate principal component 1 
g = prcomp(tmat, scale = TRUE)

# get the dsb technical component for each cell -- PC1 scores (position along PC1) for each cell 
g$x %>% head 
g$rotation %>% head 
technical_component = g$x[ ,1]

hist(technical_component, breaks = 40)
```

## dsb part II step III 

Regress out the technical component from the ambient corrected values from dsb step I

```{r}
# regress out the technical component using limma 
# note this is how limma (and dsb) calculates this 
denoised_adt = limma::removeBatchEffect(norm_adt, covariates = technical_component)

```

## code within the technical component regression 

Under the hood the limma removeBatchEffect function is not doing anything related to a 'batch'. We use this code as a simple way to carry out the steps below for regressing out the technical component. limma::removeBatchEffect is equivalent to the code below. 

```{r}
# under the hood removeBatchEffect is equivalent to the code below in steps:
covariates = as.matrix(technical_component)

# constructs a matrix of 1 by number of columns in norm_adt1
design = matrix(1, ncol(norm_adt), 1)

# X.batch <- cbind(batch, batch2, covariates)
covariates <- as.matrix(covariates)
X.batch = covariates

# X.batch is just the noise vector as a single column matrix. 
X.batch %>% head 

# fit a linear model to solve the coefficient for each protein with QR decomposition. 
fit <- limma::lmFit(norm_adt, cbind(design, X.batch))

# this subset just extracts the beta for each protein. 
beta <- fit$coefficients[, -(1:ncol(design)), drop = FALSE]
beta[is.na(beta)] <- 0

# beta is the coefficient for each prot. 
beta 

```

Regress out the technical component from the ambient corrected values.  
**t(X.batch) is the PC1 score (technical component) for each cell**  
%*% is carrying out matrix multiplication of the fitted value for beta from the linear model across the technical component scores for each cell -- this is subtracted from the ambient corrected values norm_adt

```{r}

denoised_adt_2 = as.matrix(norm_adt) - beta %*% t(X.batch)

```

Confirm the dimensions of the subtracted matrix are equal to the dimensions as norm_adt, the ambient background corrected values from step I.  

```{r}
test = beta %*% t(X.batch) 
test[1:4,1:4]
dim(test)
```


We can confirm these steps above are equivalent to what is output from the dsb function. 

```{r}

# default dsb call 
denoised_adt_3 = DSBNormalizeProtein(cell_protein_matrix = h1, 
                                     empty_drop_matrix = neg, 
                                     denoise.counts = TRUE, 
                                     isotype.control.name.vec = isotype.control.name.vec)

# check these are the same: 
all.equal(denoised_adt, denoised_adt_2, denoised_adt_3)
# [1] TRUE

```

Compare the distributions of the denoised and non denoised data.

```{r, fig.width=8}
# denoised 
p1 = qplot(as.data.frame(t(norm_adt))$CD4_PROT, 
      as.data.frame(t(norm_adt))$CD14_PROT, size = I(0.2)) + 
  ggtitle('dsb step 1: background rescaled') + 
  xlim(c(-5, 15)) + ylim(c(-5,15)) + 
  geom_density_2d(color = 'red') +
  geom_vline(xintercept = 0) + geom_hline(yintercept = 0)

# non-denoised 
p2 = qplot(as.data.frame(t(denoised_adt_3))$CD4_PROT, 
      as.data.frame(t(denoised_adt_3))$CD14_PROT, size = I(0.2)) + 
  ggtitle('dsb step 1 and 2') + 
  xlim(c(-5, 15)) + ylim(c(-5,15)) + 
  geom_density_2d(color = 'red') + 
  geom_vline(xintercept = 0) + geom_hline(yintercept = 0)
cowplot::plot_grid(p1,p2,nrow = 1)
```
